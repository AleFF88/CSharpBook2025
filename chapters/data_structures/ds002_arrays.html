<h2>Массивы.</h2>
<p>
    В языке C# массив — это структура данных, которая хранит <b>фиксированное</b> количество элементов <b>одного</b> типа.
    Базовым классом для массивов является System.Array, который происходит от <a href="https://www.example.com">System.Object</a>. Следовательно массивы являются <a href="https://www.example.com">ссылочным типом</a> данных и размещаются в <a href="https://www.example.com">управляемой куче</a>. Так же из этого следует то, что переменная не содержит сам массив, а только указатель на него в куче.<br><br>

    При выделении пямяьт под массив в куче помимо места под сами элементы, дополнительно выделчется место под метаинформацию о массиве. Она нужна для управления данными и выполнения операций с массивом. Вот основные компоненты:<br>
    <ul>
        <li>Длина массива (.Length). В памяти хранится информация о количестве элементов, чтобы можно было быстро получить значение `array.Length`.</li>
        <li>Тип данных элементов. Система должна знать, какие типы данных хранятся в массиве, особенно при работе с ссылочными типами.</li>
        <li>Метаданные для работы с GC (Garbage Collector). Если массив содержит ссылочные типы, GC использует дополнительную информацию, чтобы отслеживать объекты и управлять их очисткой.</li>
        <li>Выравнивание и служебная информация. В зависимости от архитектуры процессора массив может занимать чуть больше памяти из-за "выравнивания" данных (alignment) для быстрого доступа.</li>
    </ul><br>
</p>


<hr>
<h3>Создание массивов.</h3>
<p>
    <pre><code class="language-csharp">
        int[] numbers;
        numbers = new int[] { 1, 2, 3, 4, 5 };
        foreach (int number in numbers)
        {
            Console.WriteLine(number);
        }
    </code></pre>
    В данном фрагменте кода сначала мы объявляем переменную массива, начальное значение которой будет null. В следующей строке мы создаем сам массив, заполняем его данными и помещяем ссылку в ранее созданную переменную. Компилятор автоматически выделит память на необходимое количество элементов и размерность массива станет равна 5 элементам. При необходимости мы можем явно указать размерность массива при его создании <code>numbers = new int[100];</code><br>
    Обратите внимание, что нумерация элементов в массиве начинается с 0.
</p>

<p>
    Массивы можно создавать не указывая тип данных, если сразу происходит инициализация значений массива. Компилятор сам определит тип данных и размерность массива.
    <pre><code class="language-csharp">
        var stringArray = new[] {"foo","fighters","band"};
    </code></pre>
    Так же возможно явно указать тип переменной и не использовать оператор <code>new</code>.
    <pre><code class="language-csharp">
        String[] stringArray = {"foo","fighters","band"};
    </code></pre>
    При использовании таких способов инициализации следует соблюдать соглашение о коде (code convention), принятое в вашей организации.<br>
</p>


<hr>
<h3>Копирование массивов.</h3>
<p>
    Массив нельзя скопировать просто выполнив операцию присвоения с переменными:
    <pre><code class="language-csharp">
        int[] numbers1 = new int[3] {1,2,3};
        int[] numbers2 = new int[3];
        numbers2 = numbers1;
    </code></pre>
    Поскольку массивы являются ссылочным типом, то мы получим не копию первого массива, а ссылку на него же. Фактически обе переменные будут ссылаться на один и тот же участок памяти. При изменении данных с использованим первой переменной, мы увидим то же самое изменение при обращении ко второй переменной. Для копирования данных одного массива в другой можно применить встроенный в System.Array метод копирования:
    <pre><code class="language-csharp">
        Array.Copy(numbers1, numbers2, numbers1.Length);
    </code></pre>
    При этом следует контролировать, что размерность массивов равна.  Этот метод так же позволяет копировать не весь массив целиком, а только определенную его часть. <br>
    В этом случае мы не создаем новый массив, а переносим данные из исходного массива в целевой. Целевой массив уже должен быть создан.<br>
    <details>
        <summary>Пример <b>неправильного</b> копирование массива. Показать/скрыть код</summary>
        <p>
            <pre> <code>
            int[] original = new int[3] { 1, 2, 3 };
            int[] copied = new int[3];
            copied = original;

            copied[0] = 10;
            PrintArray(original);
            PrintArray(copied);

            void PrintArray(int[] arr) {
                for (int i = 0; i < arr.Length; i++) {
                    Console.WriteLine($" item {i} = {arr[i]}");
                }
                Console.WriteLine();
            }
        </code></pre>
            Результат будет выглядеть следующим образом:
            <br>item 0 = 10
            <br>item 1 = 2
            <br>item 2 = 3
            <br>
            <br>item 0 = 10
            <br>item 1 = 2
            <br>item 2 = 3
        </p>
    </details>
    <details>
        <summary>Пример <b>правильного</b> копирование массива. Показать/скрыть код</summary>
        <p>
            <pre> <code>
            int[] original = new int[3] { 1, 2, 3 };
            int[] copied = new int[3];

            Array.Copy(original, copied, original.Length);
            copied[0] = 100;
            PrintArray(original);
            PrintArray(copied);         
        </code></pre>
            Результат будет выглядеть следующим образом:
            <br>item 0 = 1
            <br>item 1 = 2
            <br>item 2 = 3
            <br>
            <br>item 0 = 100
            <br>item 1 = 2
            <br>item 2 = 3
        </p>
    </details>
</p>
<p>
    В отличие от метода копирования массива есть метод Clone(), который  <b>создает новый массив</b> того же типа и копирует туда все элементы.
    <pre><code class="language-csharp">
        int[] original = { 1, 2, 3 };
        int[] cloned = (int[])original.Clone(); // Создает новый массив
        int[] copied = new int[3];
        original.CopyTo(copied, 0); // Копирует в существующий массив
    </code></pre>
    Обратите внимание, что в обоих случаях выполняется <b>поверхностное копирование данных</b>. Если массив содержит данные ссылочного типа (например, массив объектов), то копируются только ссылки, а не сами объекты. В C# нет встроенного метода, который автоматически создаёт глубокую копию массива со всеми вложенными объектами. <br><br>
</p>


<hr>
<h3>Применение LINQ</h3>
<p>
    Так же для копирования массивов можно применять запросы LINQ.
    <pre><code class="language-csharp">
        int[] original = { 1, 2, 3 };
        int[] copy = original.Select(x => x).ToArray(); // Создаёт новый массив
    </code></pre>
    Этот способ аналогичен поверхностному копированию с помощью Clone()<br>

    С использованием LINQ можно реализовать глубокое копирование массива:
    <pre><code class="language-csharp">
        class Person {
            public string Name { get; set; }        
            public Person(string name) => Name = name;        // Конструктор
            public Person(Person other) => Name = other.Name; // Конструктор копирования
        }

        Person[] original = { new Person("Alice"), new Person("Bob") };
        Person[] deepCopy = original.Select(p => new Person(p)).ToArray(); // Копируем объекты
    </code></pre>
</p>


<hr>
<h3>Многомерные и зубчатые массивы</h3>
<p>
    При необходимости можно создавать и многомерные массивы (int[,]), но данные структуры буду работать в C# медленее чем хотелось бы из-за особенностей доступа к памяти. Использование таких структур данных должно быть оправдано. Чтобы минимизировать потери производительности, применяют несколько стратегий:
    <ul>
        <li>Использование зубчатых массивов (jagged arrays). Зубчатые массивы (int[][]) эффективнее, чем классические многомерные (int[,]), потому что они хранятся как массив массивов, а не как цельный блок памяти. Каждая строка массива хранится отдельно, а доступ к элементам происходит быстрее из-за лучшего кэширования данных.</li>
        <li>Линейное хранение вместо многомерных массивов. Часто можно заменить int[,] на одномерный массив и вычислять индексы вручную. Доступ к памяти более последовательный, что ускоряет работу из-за лучшего использования кэш-памяти процессора.</li>
        <li>Оптимизация алгоритмов доступа к данным, чтобы минимизировать количество обращений к памяти. Так как в памяти массив int[,] хранится по строкам, то при итерации по многомерным массивам важно перебирать элементы по строкам, а не по столбцам.</li>
    </ul><br>
</p>


<hr>
<h3>Передача переменного количества аргументов в метод (params).</h3>
<p>
    Эта тема не совсем про массивы, но тесно связана с ними. В C# можно создавать методы, которые принимают переменное количество аргументов, используя ключевое слово <code>params</code>. Это позволяет передавать массивы или список значений в метод без необходимости явно создавать массив.<br>
    <pre><code class="language-csharp">
        void PrintNumbers(params int[] numbers) {
            foreach (var number in numbers) {
                Console.WriteLine(number);
            }
        }

        PrintNumbers(1, 2, 3); // Выводит 1, 2, 3
        PrintNumbers(4, 5);    // Выводит 4, 5

        int[] values = { 10, 20, 30 };
        PrintNumbers(values);  // Выводит 10, 20, 30
    </code></pre>

    Особенности `params` аргумента:
    <ul>
        <li>Можно передавать любое количество аргументов, включая ноль.</li>
        <li>Могут быть использованы с любыми типами данных.</li>
        <li>Аргументы автоматически собираются в массив внутри метода.</li>
        <li>Если метод принимает `params`, то он должен быть последним параметром в списке параметров метода.</li>
    </ul>
</p>

