<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <title>Списки</title>
</head>
<body>
  <h1>Списки</h1>

  <h2>Общее описание списка</h2>
  <p>Список представляет собой строго типизированный список объектов, к которым можно получить доступ по индексу. Обобщённый (generic) класс <code>List&lt;T&gt;</code> — это обобщённая коллекция. Он находится в пространстве имён <code>System.Collections.Generic</code>. Список является ссылочным типом. В стеке хранится ссылка на объект списка, а сам объект размещается в куче. Список — это ссылочный тип, и потому передача его в метод означает передачу ссылки, а не копии. Т.е. изменения списка внутри метода будут видны вне метода.</p>

  <h2>Создание списка</h2>
  <pre><code class="language-csharp">
var list = new List&lt;int&gt;();
var list = new List&lt;int&gt; { 1, 2, 3 }; // Инициализация с элементами
  </code></pre>
  <p>Следует отметить, что в качестве типа T может выступать как простой тип данных, так и более сложные типа пользовательских классов.</p>
  
  
  <h2>Особенности реализации</h2>
  <p>Класс <code>List&lt;T&gt;</code> в .NET реализован на основе массива. То есть в его внутренней реализации используется обычный массив (<code>T[]</code>), но обёрнутый в более удобный API. Когда мы добавляем элементы в список (<code>Add</code>, <code>AddRange</code> и т. д.), и если текущий массив переполняется, <code>List&lt;T&gt;</code> автоматически создаёт новый массив большего размера (обычно в 2 раза больше предыдущего), копирует туда все старые элементы и продолжает работу. Это позволяет достичь баланса между производительностью и удобством.</p>
  <p>Таким образом, список сочетает производительность массивов с гибкостью динамического изменения размера.</p>
  <p>Чтобы обратиться к элементу списка в C#, используется индексация, как у обычного массива.</p>
  <pre><code class="language-csharp">
Console.WriteLine(list[0]);
  </code></pre>
  <p>Следовательно доступен перебор через <code>foreach</code> и <code>for</code>. В отличие от массива, у списка есть встроенные удобные методы поиска и сортировки по типу <code>Find</code>, <code>IndexOf</code>, <code>Sort</code> и т.д.</p>


  <h2>Ресайзинг</h2>
  <p>Если мы добавляем элемент в список и внутренняя емкость уже исчерпана, то происходит следующее:</p>
  <ul>
    <li>Создается новый массив в два раза больше текущей емкости.</li>
    <li>Все элементы из старого массива поэлементно копируются в новый массив. Это дорогостоящая операция по времени, потому что каждое копирование требует перебора всего массива.</li>
    <li>Заменяется ссылка. Список теперь начинает использовать новый массив вместо старого. При этом старый массив становится недоступным и может быть собран сборщиком мусора.</li>
  </ul>
  <p>При создании пустого списка его начальная емкость равна 0, а внутренний массив пуст. Первый вызов <code>Add()</code> вызывает ресайз и выделяет массив на 4 элемента. Далее емкость обычно увеличивается в 2 раза.</p>
  <p>Если нам заранее известна потребная емкость списка, то можно создавать его сразу с определённым размером внутреннего массива, чтобы избежать ненужного ресайзинга.</p>
  <pre><code class="language-csharp">
var list = new List&lt;int&gt;(1000);
  </code></pre>
  <p>В этом контексте полезно различать <strong>Capacity</strong> и <strong>Count</strong>:</p>
  <ul>
    <li><strong>Count</strong> показывает фактическое количество элементов, находящихся в списке. Это число элементов, которые были добавлены.</li>
    <li><strong>Capacity</strong> показывает количество элементов, которое список может вместить без перераспределения памяти. Это внутренний размер выделенного массива под капотом. При добавлении элементов, если <code>Count</code> превысит <code>Capacity</code>, список автоматически увеличит <code>Capacity</code>.</li>
  </ul>
  
  
  <h2>Добавление и удаление элементов</h2>
  <ul>
    <li><code>Add(T item)</code> — добавляет один элемент в конец списка.</li>
    <li><code>AddRange(IEnumerable&lt;T&gt; collection)</code> — добавляет в конец несколько элементов. Эффективнее, чем последовательные вызовы <code>Add()</code>.<br>
	Следует избегать частого добавления большого количества элементов по одному — лучше использовать <code>AddRange()</code>, так как список сразу увеличивает <code>Capacity</code>, чтобы вместить все новые элементы. К тому же каждый вызов <code>Add()</code> проверяет: хватает ли места в массиве. При <code>AddRange()</code> меньше вызовов метода и проверок.</li>
    <li><code>Insert(int index, T item)</code> — вставляет элемент по индексу, сдвигая остальные вправо.</li>
    <li><code>InsertRange(int index, IEnumerable&lt;T&gt;)</code> — вставляет несколько элементов по индексу.</li>
    <li><code>Remove(T item)</code> — удаляет первое вхождение элемента (если найдено). Если элемент не найден — ничего не происходит. Возвращает true, если элемент был найден и удалён. Остальные элементы сдвигаются влево.</li>
    <li><code>RemoveAt(int index)</code> — удаляет элемент по индексу.</li>
    <li><code>Clear()</code> — удаляет все элементы, <code>Count</code> = 0, но <code>Capacity</code> сохраняется.</li>
  </ul>
  <p>При использовании <code>Insert()</code> или <code>RemoveAt()</code> необходимо проверять допустимость индексов — иначе произойдёт <code>ArgumentOutOfRangeException</code>.</p>

  <pre><code class="language-csharp">
var list = new List&lt;string&gt;();
list.Add("apple");                             // ["apple"]
list.AddRange(new[] { "banana", "cherry" });   // ["apple", "banana", "cherry"]
list.Insert(1, "orange");                      // ["apple", "orange", "banana", "cherry"]
list.Remove("banana");                         // ["apple", "orange", "cherry"]
list.RemoveAt(0);                              // ["orange", "cherry"]
list.Clear();                                  // []
  </code></pre>

  <p><code>TrimExcess()</code> уменьшает <code>Capacity</code> до 0:</p>
  <pre><code class="language-csharp">
var list = new List&lt;int&gt;(1000);  // Capacity = 1000
list.Add(1);                     // Count = 1
list.Clear();                    // Count = 0, Capacity = 1000
list.TrimExcess();               // Capacity теперь уменьшен до 0
  </code></pre>

  <p>В <code>List&lt;T&gt;</code> нет метода, позволяющего напрямую задать <code>Capacity</code> в меньшую сторону. Обычно используют пересоздание списка нужной длины.</p>


  <h2>Копирование и преобразование</h2>
  <p>Метод <code>ToArray()</code> создаёт поверхностную копию элементов:</p>
  <pre><code class="language-csharp">
var list = new List&lt;int&gt; { 1, 2, 3 };
int[] array = list.ToArray();
  </code></pre>

  <p>Список не реализует интерфейс <code>ICloneable</code>, поэтому глубокого клонирования «из коробки» нет. Чтобы сделать поверхностную копию списка, можно использовать конструктор:</p>
  <pre><code class="language-csharp">
var clone = new List&lt;int&gt;(originalList);
  </code></pre>

  <p>Список реализует интерфейс <code>IEnumerable&lt;T&gt;</code>, поэтому можно применять к нему LINQ-операции.</p>
  <pre><code class="language-csharp">
var list = new List&lt;int&gt; { 1, 2, 3, 4, 5 };
// Умножим каждый элемент на 10 и получим новый список
var newList = list.Select(x =&gt; x * 10).ToList(); // newList = [10, 20, 30, 40, 50]
  </code></pre>

  <p>При использовании LINQ для копирования мы получаем опять-таки поверхностное копирование. Однако если в LINQ-запрос вставить создание копии элемента (метод клонирования оригинального объекта) или конструктор, то можно получить глубокую копию:</p>
  <pre><code class="language-csharp">
var deepCopy = list.Select(p =&gt; p.Clone()).ToList();
  </code></pre>

  <p>Также можно получить срез списка (подмножество) в виде отдельной независимой копии (поверхностное копирование):</p>
  <pre><code class="language-csharp">
var subList = list.GetRange(2, 3); // берёт 3 элемента начиная с индекса 2
  </code></pre>


  <h2>Списки списков или зубчатые списки</h2>
  <p>Это аналог двумерного массива, но с некоторыми отличиями. Внутренние списки могут иметь разную длину, причём легко её менять. Также у списка списков есть важное преимущество — мы можем легко удалить внутренний список целиком или вставить дополнительный.</p>
  <p>При этом доступ к элементам внутренних списков медленнее из-за двух уровней индексации. В массиве доступ быстрее, так как память адресуется непрерывно.</p>
  <p><strong>Когда использовать зубчатые списки?</strong></p>
  <ul>
    <li>Когда нужна структура с переменным размером строк.</li>
    <li>Когда требуется добавлять или удалять отдельные строки или столбцы динамически.</li>
    <li>Когда нужен удобный и гибкий способ представления матриц с разной длиной строк.</li>
  </ul>

  <h2>Потокобезопасность</h2>
  <p>Списки не являются потокобезопасными и у них нет встроенной защиты от параллельного доступа.</p>
  <p>Это значит, что одновременное добавление, удаление, чтение или изменение данных из разных потоков может привести к:</p>
  <ul>
    <li>исключениям (<code>IndexOutOfRangeException</code>, <code>InvalidOperationException</code>),</li>
    <li>нарушению внутренней структуры списка (непредсказуемое поведение),</li>
    <li>потере или повреждению данных.</li>
  </ul>
  <p><strong>1. Классический способ — <code>lock</code>:</strong></p>
  <pre><code class="language-csharp">
List&lt;int&gt; list = new List&lt;int&gt;();
object locker = new object();
Parallel.For(0, 10000, i =&gt;
{
    lock (locker)
    {
        list.Add(i); // Безопасно
    }
});
  </code></pre>
  <ul>
    <li><strong>Минусы:</strong></li>
    <li>Снижает производительность из-за блокировок.</li>
    <li>Не решает проблему, если забыть поставить <code>lock</code> в одном месте.</li>
  </ul>

  <p><strong>2. <code>ImmutableList&lt;T&gt;</code></strong></p>
  <p>Это неизменяемый список, т.е. коллекция, которую нельзя изменить после создания.</p>
  <p>Основная идея: все операции, кажущиеся «изменяющими», возвращают новый список, а оригинальный остаётся неизменным.</p>
  <pre><code class="language-csharp">
var original = ImmutableList.Create&lt;int&gt;(1, 2, 3);
var modified = original.Add(4);
Console.WriteLine(string.Join(", ", original));  // 1, 2, 3
Console.WriteLine(string.Join(", ", modified));  // 1, 2, 3, 4
  </code></pre>
  <ul>
    <li><strong>Минусы:</strong></li>
    <li>Производительность хуже, чем у <code>List&lt;T&gt;</code> при частом изменении: каждая операция создаёт новую копию.</li>
    <li>Требует подключения NuGet-пакета: dotnet add package System.Collections.Immutable
      <pre><code class="language-csharp">
using System.Collections.Immutable;
      </code></pre>
    </li>
  </ul>

  <p><strong>3. Использовать <code>ConcurrentQueue&lt;T&gt;</code>, <code>ConcurrentDictionary&lt;K,V&gt;</code> и т. д.</strong></p>
  <p>Если нужна коллекция, пригодная для многопоточности из коробки, лучше использовать предназначенные для этого структуры данных.</p>
  <p><strong>TODO:</strong> сделать ссылку на отдельную главу про потокобезопасные коллекции</p>


  <p><strong>TODO:</strong> сделать раздел про особенности работы, если <code>T</code> — это <code>struct</code> (значимый тип)</p>

  <h2>Особенности применения списков в сравнении с "чистыми" массивами</h2>
  <p>Исходя из описанного выше, можно сделать следующие выводы:</p>

  <p><strong>1. Когда массив быстрее:</strong></p>
  <ul>
    <li>Инициализация массива фиксированного размера быстрее, чем динамический список, особенно если мы уже знаем нужное количество элементов.</li>
    <li>Обращение по индексу и перебор — идентичны по скорости у массива и список, так как оба используют массив под капотом. Но массив иногда выигрывает за счёт отсутствия дополнительных проверок.</li>
    <li>Накладные расходы: массив — это «чистая» структура данных без лишних методов, тогда как список — полноценный класс с логикой управления размером и методами.</li>
  </ul>

  <p><strong>2. Когда список удобнее, а разница в скорости не критична:</strong></p>
  <ul>
    <li>При неизвестном количестве элементов — список гораздо удобнее, так как не нужно заботиться о перераспределении массива вручную.</li>
    <li>Также важным преимуществом списков перед массивами может стать список списков.</li>
  </ul>

  <p><strong>3. Когда разница становится заметной:</strong></p>
  <ul>
    <li>В сценариях с миллионами элементов и высокочастотным доступом, например в играх, рендеринге или системах реального времени — массивы предпочтительнее.</li>
  </ul>

</body>
</html>
