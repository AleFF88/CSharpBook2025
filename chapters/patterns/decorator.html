<!DOCTYPE html>
<html><head><meta charset="utf-8"><title>Паттерн Декоратор (обертка)</title></head><body>
<h2>Паттерн Декоратор (обертка)</h2>
Это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в другие объекты-декораторы. Он реализует принцип открытости/закрытости: классы открыты для расширения, но закрыты для модификации.<br>
<br>
Например, нам надо реализовать некоторый базовый функционал, а так же несколько расширений. Паттерн Декоратор прекрасно иллюстрируется на примере с кофе, где у нас есть базовый напиток (кофе), и нам нужны вариации с сахаром или молоком, а так же одновременно с сахаром и молоком.<br>
Как правило, первым приходит в голову создание цепочки наследования классов с постепенным расширением функционала. Но тут есть несколько проблем. При наследовании мы не можем наследовать поведение нескольких классов одновременно. Из-за этого нам приходится создавать множество подклассов-комбинаций для получения совмещённого поведения.<br>
Т.е. мы должны иметь класс для простого кофе, для кофе с сахаром, для кофе с молоком и для кофе с сахаром и молоком. Итого 4 класса на 2 добавки. <br>
А для трех добавок это уже будет 8 классов. При дальнейшем увеличении количества добавок мы получаем так называемый &quot;комбинаторный взрыв&quot;. Паттерн декоратор позволяет реализовать это без проблемы комбинаторного взрыва.<br>
<br>
Одним из способов обойти эти проблемы является замена наследования агрегацией либо композицией. Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его поведение. Как раз на этом принципе построен паттерн Декоратор. Мы помещаем целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.<br>
Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Мы можем использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.<br>
<br>
Базовый интерфейс, описывающий что должен делать класс<br>
<pre><code>	public interface ICoffee {
		string GetDescription();
		double GetCost();
	}
</code></pre>
<br>
Класс, имплементирующий простой кофе:<br>
<pre><code>	public class SimpleCoffee : ICoffee {
		public string GetDescription() =&gt; &quot;Чёрный кофе&quot;;
		public double GetCost() =&gt; 50.0;
	}
</code></pre>
<br>
Базовый декоратор (это абстрактный класс), который будет наследоваться &quot;расширителями&quot;:<br>
<pre><code>	public abstract class CoffeeDecorator : ICoffee{
		protected ICoffee coffee;
		public CoffeeDecorator(ICoffee coffee) {
			this.coffee = coffee;
		}
		public virtual string GetDescription() =&gt; coffee.GetDescription();
		public virtual double GetCost() =&gt; coffee.GetCost();
	}
</code></pre>
<br>
Декоратор Сахар. <br>
Наследует от базового декоратора и принимает на вход класс, реализающий базовый интерфейс. Т.е. расширяет поведение переданного в него класса, добавляя к нему сахар. Не базового класса, а переданного в конструктор класса, т.е. любого, который соответствует базовому интерфейсу.<br>
<pre><code>	public class SugarDecorator : CoffeeDecorator{
		public SugarDecorator(ICoffee coffee) : base(coffee) { }
		public override string GetDescription() =&gt; coffee.GetDescription() + &quot;, с сахаром&quot;;
		public override double GetCost() =&gt; coffee.GetCost() + 5.0;
	}
</code></pre>
<br>
Декоратор Молоко. <br>
То же самое, но с молоком.<br>
<pre><code>	public class MilkDecorator : CoffeeDecorator{
		public MilkDecorator(ICoffee coffee) : base(coffee) { }
		public override string GetDescription() =&gt; coffee.GetDescription() + &quot;, с молоком&quot;;
		public override double GetCost() =&gt; coffee.GetCost() + 10.0;
	}
</code></pre>
<br>
По сути у нас есть два класса, расширяющих функционал переданных в них классов.<br>
Еще раз обратите внимание, что эти классы расширяют поведение не базового класса, а именно того класса, что был передан в них.<br>
<br>
Использование:<br>
1. Вариант кофе с сахаром и молоком:<br>
<pre><code>	class Program{
		static void Main(){
			ICoffee coffee = new SimpleCoffee();
			coffee = new SugarDecorator(coffee);
			coffee = new MilkDecorator(coffee);
			Console.WriteLine(coffee.GetDescription()); // Чёрный кофе, с сахаром, с молоком
			Console.WriteLine(&quot;Цена: &quot; + coffee.GetCost() + &quot; грн.&quot;);
		}
	}
</code></pre>
<br>
Вывод:<br>
&nbsp;&nbsp;&nbsp;&nbsp;Чёрный кофе, с сахаром, с молоком  <br>
&nbsp;&nbsp;&nbsp;&nbsp;Цена: 65 грн.<br>
<br>
2. Вариант с двойным сахаром:<br>
<pre><code>	class Program{
		static void Main(){
			ICoffee coffee = new SimpleCoffee();
			coffee = new SugarDecorator(coffee);
			coffee = new SugarDecorator(coffee);
			Console.WriteLine(coffee.GetDescription()); 
			Console.WriteLine(&quot;Цена: &quot; + coffee.GetCost() + &quot; грн.&quot;);
		}
	}
</code></pre>
<br>
Вывод:<br>
&nbsp;&nbsp;&nbsp;&nbsp;Чёрный кофе, с сахаром, с сахаром<br>
&nbsp;&nbsp;&nbsp;&nbsp;Цена: 60 грн.<br>
<br>
Итого:<br>
Декоратор — это способ расширять поведение объектов без изменения их кода.  комбинировать декораторы и расширять систему. Его можно представить как цепочку ответственности, где каждый слой добавляет поведение и передаёт управление дальше. Он особенно полезен, когда нужно гибко комбинировать функциональность, не опасаясь комбинаторного взрыва. Главное — соблюдать единый интерфейс, контролировать порядок обёртывания и не злоупотреблять глубиной вложенности.<br>
<br>
Применение:<br>
&nbsp;&nbsp;&nbsp;&nbsp;* Расширение функционала объектов, наследовать которые нельзя. Это, например, sealed классы или классы из библиотек или фреймворках, где мы не контролируем исходный код, но хотим адаптировать поведение. Мы оборачиваем их в декоратор и расширяем поведение.<br>
&nbsp;&nbsp;&nbsp;&nbsp;* Так же можно использовать для задач типа логирования, кэширования, валидации или аутентификации.<br>
<br>
<h3>ШАГИ РЕАЛИЗАЦИИ</h3>
Первоначальное условие: В задаче есть один основной компонент и требуется несколько опциональных дополнений или надстроек над ним.<br>
Действия:<br>
&nbsp;&nbsp;&nbsp;&nbsp;1. Создаем интерфейс компонента (ICoffee), который описывал бы общие методы как для основного компонента, так и для его дополнений.<br>
&nbsp;&nbsp;&nbsp;&nbsp;2. Создаем (если не создан) класс конкретного компонента и помещаем в него основную бизнес-логику (SimpleCoffee).<br>
&nbsp;&nbsp;&nbsp;&nbsp;3. Создаем базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент (protected ICoffee coffee;). Все методы базового декоратора должны делегировать действие вложенному объекту (coffee.GetDescription()).<br>
&nbsp;&nbsp;&nbsp;&nbsp;4. Создаем классы конкретных декораторов, наследуя их от базового декоратора (SugarDecorator, MilkDecorator). Конкретный декоратор должен выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта. Следует убедиться что конкретный компонент, и базовый декоратор реализуют один и тот же интерфейс (ICoffee).<br>
<br>
Обратите внимание:<br>
&nbsp;&nbsp;&nbsp;&nbsp;* Порядок обёртывания имеет значение. Например, если сначала добавить молоко, а потом сахар — описание будет другим. Это может быть важно для UX или бизнес-логики.<br>
&nbsp;&nbsp;&nbsp;&nbsp;* Тестирование декораторов. Удобно тестировать каждый декоратор отдельно, как независимый модуль. Это повышает надёжность системы.<br>
&nbsp;&nbsp;&nbsp;&nbsp;* Интеграция с DI-контейнерами В современных приложениях декораторы можно регистрировать в Dependency Injection-контейнерах, например, в .NET через services.Decorate&lt;ICoffee, SugarDecorator&gt;().<br>
<br>
<h3>ПРЕИМУЩЕСТВА И НЕДОСТАКИ</h3>
Преимущества:<br>
&nbsp;&nbsp;&nbsp;&nbsp;* Б&#39;ольшая гибкость, чем у наследования. <br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Комбинирование &quot;расширений&quot; без комбинаторного взрыва.<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Возможность расширеная классов, наследование от которых недоступно.<br>
&nbsp;&nbsp;&nbsp;&nbsp;* Позволяет добавлять &quot;расширения&quot; на лету.<br>
&nbsp;&nbsp;&nbsp;&nbsp;* Позволяет иметь несколько мелких объектов вместо одного объекта с большим количеством функций. Это упрощает читабильности и тестирование.<br>
<br>
Недостаки:<br>
&nbsp;&nbsp;&nbsp;&nbsp;* Декоратор не стоит использовать в том случае, поведение не должно зависить от порядка применения или строго определено и не меняется динамически.<br>
&nbsp;&nbsp;&nbsp;&nbsp;* Иногда проще использовать конфигурационные объекты или флаги.<br>
&nbsp;&nbsp;&nbsp;&nbsp;* Проблема &quot;глубокой вложенности&quot;. При большом количестве обёрток могут быть сложности с конфигурацией или контролем, что именно происходит. Это можно решить через логирование или визуализацию цепочки. Или же количество возможных комбинаций всё равно велико и проще использовать конфигурационные параметры.<br>
<br>
<h3>ДОПОЛНИТЕЛЬНЫЕ ПРИМЕРЫ</h3>
Пример с логированием:<br>
<pre><code>	public class LoggingDecorator : CoffeeDecorator {
		public LoggingDecorator(ICoffee coffee) : base(coffee) { }
		public override string GetDescription() {
			Console.WriteLine(&quot;Вызван GetDescription&quot;);
			return coffee.GetDescription();
		}
		public override double GetCost() {
			Console.WriteLine(&quot;Вызван GetCost&quot;);
			return coffee.GetCost();
		}
	}
</code></pre>
<br>
Пример с &quot;кешированием&quot; результата GetCost():<br>
<pre><code>	public class CachingDecorator : CoffeeDecorator {
		private double? cachedCost = null;
		public CachingDecorator(ICoffee coffee) : base(coffee) { }
		public override double GetCost() {
			if (cachedCost == null) cachedCost = coffee.GetCost();
			return cachedCost.Value;
		}
	}
</body></html>
