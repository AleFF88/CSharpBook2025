Паттерн Декоратор (обертка)
Это структурный паттерн проектирования, который позволяет динамически добавлять объектам новую функциональность, оборачивая их в другие объекты-декораторы. Он реализует принцип открытости/закрытости: классы открыты для расширения, но закрыты для модификации.

Например, нам надо реализовать некоторый базовый функционал, а так же несколько расширений. Паттерн Декоратор прекрасно иллюстрируется на примере с кофе, где у нас есть базовый напиток (кофе), и нам нужны вариации с сахаром или молоком, а так же одновременно с сахаром и молоком.
Как правило, первым приходит в голову создание цепочки наследования классов с постепенным расширением функционала. Но тут есть несколько проблем. При наследовании мы не можем наследовать поведение нескольких классов одновременно. Из-за этого нам приходится создавать множество подклассов-комбинаций для получения совмещённого поведения.
Т.е. мы должны иметь класс для простого кофе, для кофе с сахаром, для кофе с молоком и для кофе с сахаром и молоком. Итого 4 класса на 2 добавки. 
А для трех добавок это уже будет 8 классов. При дальнейшем увеличении количества добавок мы получаем так называемый "комбинаторный взрыв". Паттерн декоратор позволяет реализовать это без проблемы комбинаторного взрыва.

Одним из способов обойти эти проблемы является замена наследования агрегацией либо композицией. Это когда один объект содержит ссылку на другой и делегирует ему работу, вместо того чтобы самому наследовать его поведение. Как раз на этом принципе построен паттерн Декоратор. Мы помещаем целевой объект в другой объект-обёртку, который запускает базовое поведение объекта, а затем добавляет к результату что-то своё.
Оба объекта имеют общий интерфейс, поэтому для пользователя нет никакой разницы, с каким объектом работать — чистым или обёрнутым. Мы можем использовать несколько разных обёрток одновременно — результат будет иметь объединённое поведение всех обёрток сразу.

Базовый интерфейс, описывающий что должен делать класс
	public interface ICoffee {
		string GetDescription();
		double GetCost();
	}

Класс, имплементирующий простой кофе:
	public class SimpleCoffee : ICoffee {
		public string GetDescription() => "Чёрный кофе";
		public double GetCost() => 50.0;
	}

Базовый декоратор (это абстрактный класс), который будет наследоваться "расширителями":
	public abstract class CoffeeDecorator : ICoffee{
		protected ICoffee coffee;
		public CoffeeDecorator(ICoffee coffee) {
			this.coffee = coffee;
		}
		public virtual string GetDescription() => coffee.GetDescription();
		public virtual double GetCost() => coffee.GetCost();
	}

Декоратор Сахар. 
Наследует от базового декоратора и принимает на вход класс, реализающий базовый интерфейс. Т.е. расширяет поведение переданного в него класса, добавляя к нему сахар. Не базового класса, а переданного в конструктор класса, т.е. любого, который соответствует базовому интерфейсу.
	public class SugarDecorator : CoffeeDecorator{
		public SugarDecorator(ICoffee coffee) : base(coffee) { }
		public override string GetDescription() => coffee.GetDescription() + ", с сахаром";
		public override double GetCost() => coffee.GetCost() + 5.0;
	}

Декоратор Молоко. 
То же самое, но с молоком.
	public class MilkDecorator : CoffeeDecorator{
		public MilkDecorator(ICoffee coffee) : base(coffee) { }
		public override string GetDescription() => coffee.GetDescription() + ", с молоком";
		public override double GetCost() => coffee.GetCost() + 10.0;
	}

По сути у нас есть два класса, расширяющих функционал переданных в них классов.
Еще раз обратите внимание, что эти классы расширяют поведение не базового класса, а именно того класса, что был передан в них.

Использование:
1. Вариант кофе с сахаром и молоком:
	class Program{
		static void Main(){
			ICoffee coffee = new SimpleCoffee();
			coffee = new SugarDecorator(coffee);
			coffee = new MilkDecorator(coffee);
			Console.WriteLine(coffee.GetDescription()); // Чёрный кофе, с сахаром, с молоком
			Console.WriteLine("Цена: " + coffee.GetCost() + " грн.");
		}
	}

Вывод:
	Чёрный кофе, с сахаром, с молоком  
	Цена: 65 грн.

2. Вариант с двойным сахаром:
	class Program{
		static void Main(){
			ICoffee coffee = new SimpleCoffee();
			coffee = new SugarDecorator(coffee);
			coffee = new SugarDecorator(coffee);
			Console.WriteLine(coffee.GetDescription()); 
			Console.WriteLine("Цена: " + coffee.GetCost() + " грн.");
		}
	}

Вывод:
	Чёрный кофе, с сахаром, с сахаром
	Цена: 60 грн.

Итого:
Декоратор — это способ расширять поведение объектов без изменения их кода.  комбинировать декораторы и расширять систему. Его можно представить как цепочку ответственности, где каждый слой добавляет поведение и передаёт управление дальше. Он особенно полезен, когда нужно гибко комбинировать функциональность, не опасаясь комбинаторного взрыва. Главное — соблюдать единый интерфейс, контролировать порядок обёртывания и не злоупотреблять глубиной вложенности.

Применение:
	* Расширение функционала объектов, наследовать которые нельзя. Это, например, sealed классы или классы из библиотек или фреймворках, где мы не контролируем исходный код, но хотим адаптировать поведение. Мы оборачиваем их в декоратор и расширяем поведение.
	* Так же можно использовать для задач типа логирования, кэширования, валидации или аутентификации.
	
ШАГИ РЕАЛИЗАЦИИ
Первоначальное условие: В задаче есть один основной компонент и требуется несколько опциональных дополнений или надстроек над ним.
Действия:
	1. Создаем интерфейс компонента (ICoffee), который описывал бы общие методы как для основного компонента, так и для его дополнений.
	2. Создаем (если не создан) класс конкретного компонента и помещаем в него основную бизнес-логику (SimpleCoffee).
	3. Создаем базовый класс декораторов. Он должен иметь поле для хранения ссылки на вложенный объект-компонент (protected ICoffee coffee;). Все методы базового декоратора должны делегировать действие вложенному объекту (coffee.GetDescription()).
	4. Создаем классы конкретных декораторов, наследуя их от базового декоратора (SugarDecorator, MilkDecorator). Конкретный декоратор должен выполнять свою добавочную функцию, а затем (или перед этим) вызывать эту же операцию обёрнутого объекта. Следует убедиться что конкретный компонент, и базовый декоратор реализуют один и тот же интерфейс (ICoffee).

Обратите внимание:
	* Порядок обёртывания имеет значение. Например, если сначала добавить молоко, а потом сахар — описание будет другим. Это может быть важно для UX или бизнес-логики.
	* Тестирование декораторов. Удобно тестировать каждый декоратор отдельно, как независимый модуль. Это повышает надёжность системы.
	* Интеграция с DI-контейнерами В современных приложениях декораторы можно регистрировать в Dependency Injection-контейнерах, например, в .NET через services.Decorate<ICoffee, SugarDecorator>().

ПРЕИМУЩЕСТВА И НЕДОСТАКИ
Преимущества:
	* Б'ольшая гибкость, чем у наследования. 
		Комбинирование "расширений" без комбинаторного взрыва.
		Возможность расширеная классов, наследование от которых недоступно.
	* Позволяет добавлять "расширения" на лету.
	* Позволяет иметь несколько мелких объектов вместо одного объекта с большим количеством функций. Это упрощает читабильности и тестирование.
	
Недостаки:
	* Декоратор не стоит использовать в том случае, поведение не должно зависить от порядка применения или строго определено и не меняется динамически.
	* Иногда проще использовать конфигурационные объекты или флаги.
	* Проблема "глубокой вложенности". При большом количестве обёрток могут быть сложности с конфигурацией или контролем, что именно происходит. Это можно решить через логирование или визуализацию цепочки. Или же количество возможных комбинаций всё равно велико и проще использовать конфигурационные параметры.

ДОПОЛНИТЕЛЬНЫЕ ПРИМЕРЫ	
Пример с логированием:
	public class LoggingDecorator : CoffeeDecorator {
		public LoggingDecorator(ICoffee coffee) : base(coffee) { }
		public override string GetDescription() {
			Console.WriteLine("Вызван GetDescription");
			return coffee.GetDescription();
		}
		public override double GetCost() {
			Console.WriteLine("Вызван GetCost");
			return coffee.GetCost();
		}
	}

Пример с "кешированием" результата GetCost():
	public class CachingDecorator : CoffeeDecorator {
		private double? cachedCost = null;
		public CachingDecorator(ICoffee coffee) : base(coffee) { }
		public override double GetCost() {
			if (cachedCost == null) cachedCost = coffee.GetCost();
			return cachedCost.Value;
		}
	}